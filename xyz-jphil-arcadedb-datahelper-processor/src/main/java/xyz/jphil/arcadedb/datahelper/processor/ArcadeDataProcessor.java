package xyz.jphil.arcadedb.datahelper.processor;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.*;
import xyz.jphil.arcadedb.datahelper.ArcadeData;
import xyz.jphil.arcadedb.datahelper.ArcadeDoc_I;
import xyz.jphil.datahelper.processor.util.CodeGeneratorUtils;
import xyz.jphil.datahelper.processor.util.FieldAnalyzer;
import xyz.jphil.datahelper.processor.util.FieldInfo;
import xyz.jphil.datahelper.processor.util.ProcessorUtils;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Annotation processor that generates {ClassName}_A sealed abstract parent class.
 *
 * <p>Generated code includes:
 * <ul>
 *   <li>Sealed abstract class that permits only the annotated class</li>
 *   <li>Field symbols ($fieldName constants)</li>
 *   <li>FIELDS list (immutable)</li>
 *   <li>Delegating getters/setters (access child's package-private fields)</li>
 *   <li>Fluent accessors</li>
 *   <li>DataHelper_I implementation (15 property accessor methods)</li>
 *   <li>ArcadeDoc_I implementation</li>
 *   <li>typeDef() schema builder helper</li>
 * </ul>
 *
 * <p>The child class extends the generated sealed abstract class and declares
 * package-private fields that the parent accesses via the {@code sub} reference.</p>
 *
 * <h3>Example Usage:</h3>
 * <pre>
 * {@code @ArcadeData}
 * public final class Person extends Person_A {
 *     String name;
 *     String email;
 *     Integer age;
 * }
 * </pre>
 *
 * <p>This eliminates Lombok dependency and reduces boilerplate compared to
 * the {@code @DataHelper} + {@code @Data} pattern.</p>
 *
 * @see ArcadeData
 * @see xyz.jphil.datahelper.DataHelper_I
 * @see ArcadeDoc_I
 */
@AutoService(Processor.class)
@SupportedAnnotationTypes("xyz.jphil.arcadedb.datahelper.ArcadeData")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class ArcadeDataProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) {
                if (element.getKind() == ElementKind.CLASS) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                            "Processing @ArcadeData on " + element);
                    generateAbstractClass((TypeElement) element);
                }
            }
        }
        return true;
    }

    private void generateAbstractClass(TypeElement element) {
        String packageName = processingEnv.getElementUtils().getPackageOf(element).toString();
        String className = element.getSimpleName().toString();
        String abstractClassName = className + "_A";

        // Read the type parameter from @ArcadeData annotation
        ArcadeData annotation = element.getAnnotation(ArcadeData.class);
        String arcadeType = annotation.type().name(); // "DOCUMENT", "VERTEX", or "EDGE"

        // Initialize utilities with extended annotation list
        // Include BASE annotations (@DataHelper, @Data) + @ArcadeData
        Set<String> arcadeAnnotations = new HashSet<>(ProcessorUtils.BASE_DATA_HELPER_ANNOTATIONS);
        arcadeAnnotations.add("xyz.jphil.arcadedb.datahelper.ArcadeData");

        ProcessorUtils utils = new ProcessorUtils(processingEnv, arcadeAnnotations);
        FieldAnalyzer analyzer = new FieldAnalyzer(processingEnv, utils);

        // Analyze fields (includes validation)
        List<FieldInfo> fields = analyzer.analyzeFields(element);
        if (fields == null) {
            return; // Validation errors found
        }

        // Build sealed abstract class
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(abstractClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.SEALED)
                .addPermittedSubclass(ClassName.get(packageName, className))
                .addJavadoc("Sealed abstract base class for {@link $L}.\n", className)
                .addJavadoc("Generated by @ArcadeData annotation processor.\n")
                .addJavadoc("\n<p>This class implements both DataHelper_I and ArcadeDoc_I,\n")
                .addJavadoc("providing all accessor methods via delegation to the child class.</p>\n");

        // Implement DataHelper_I and ArcadeDoc_I
        classBuilder.addSuperinterface(ParameterizedTypeName.get(
                ClassName.get("xyz.jphil.datahelper", "DataHelper_I"),
                ClassName.get(packageName, className)
        ));
        classBuilder.addSuperinterface(ParameterizedTypeName.get(
                ClassName.get("xyz.jphil.arcadedb.datahelper", "ArcadeDoc_I"),
                ClassName.get(packageName, className)
        ));

        // Add 'sub' field for delegation (opposite of 'super')
        FieldSpec subField = FieldSpec.builder(
                        ClassName.get(packageName, className),
                        "sub",
                        Modifier.PRIVATE, Modifier.FINAL)
                .initializer("($T) this", ClassName.get(packageName, className))
                .build();
        classBuilder.addField(subField);

        // Add field symbols ($fieldName constants)
        CodeGeneratorUtils.addFieldSymbols(classBuilder, fields, packageName, className);

        // Add FIELDS list
        CodeGeneratorUtils.addFieldsList(classBuilder, fields, packageName, className);

        // Add static __ field for class name (terminal indicator pattern)
        FieldSpec classNameField = FieldSpec.builder(
                        String.class,
                        "__",
                        Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", className)
                .build();
        classBuilder.addField(classNameField);

        // Add schemaBuilder() helper
        addTypeDefHelper(classBuilder, packageName, className, arcadeType);

        // Add delegating getters
        for (FieldInfo field : fields) {
            // For boolean types, generate BOTH "is" and "get" getters for maximum compatibility
            if (ProcessorUtils.isBooleanType(field.type)) {
                // Generate isXxx() method
                String isGetterName = "is" + ProcessorUtils.capitalize(field.name);
                MethodSpec isGetter = MethodSpec.methodBuilder(isGetterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return sub.$N", field.name)
                        .build();
                classBuilder.addMethod(isGetter);

                // Generate getXxx() method (delegates to isXxx for consistency)
                String getGetterName = "get" + ProcessorUtils.capitalize(field.name);
                MethodSpec getGetter = MethodSpec.methodBuilder(getGetterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return $N()", isGetterName)
                        .build();
                classBuilder.addMethod(getGetter);
            } else {
                // For non-boolean types, use standard "get" prefix
                String getterName = "get" + ProcessorUtils.capitalize(field.name);
                MethodSpec getter = MethodSpec.methodBuilder(getterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return sub.$N", field.name)
                        .build();
                classBuilder.addMethod(getter);
            }
        }

        // Add delegating setters
        for (FieldInfo field : fields) {
            String setterName = "set" + ProcessorUtils.capitalize(field.name);
            MethodSpec setter = MethodSpec.methodBuilder(setterName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(field.type, field.name)
                    .addStatement("sub.$N = $N", field.name, field.name)
                    .build();
            classBuilder.addMethod(setter);
        }

        // Add fluent getters
        for (FieldInfo field : fields) {
            // Use "is" prefix for boolean types (primitive boolean and Boolean wrapper)
            String prefix = ProcessorUtils.isBooleanType(field.type) ? "is" : "get";
            String getterName = prefix + ProcessorUtils.capitalize(field.name);
            MethodSpec fluentGetter = MethodSpec.methodBuilder(field.name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(field.type)
                    .addStatement("return $N()", getterName)
                    .build();
            classBuilder.addMethod(fluentGetter);
        }

        // Add fluent setters (return 'sub' for chaining)
        for (FieldInfo field : fields) {
            String setterName = "set" + ProcessorUtils.capitalize(field.name);
            MethodSpec fluentSetter = MethodSpec.methodBuilder(field.name)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(field.type, field.name)
                    .returns(ClassName.get(packageName, className))
                    .addStatement("$N($N)", setterName, field.name)
                    .addStatement("return sub")
                    .build();
            classBuilder.addMethod(fluentSetter);
        }

        // ========== DataHelper_I Methods (15 property accessor methods) ==========
        // 0. dataClass()
        classBuilder.addMethod(CodeGeneratorUtils.createDataClassMethod(packageName, className));

        // 1. fieldNames()
        classBuilder.addMethod(CodeGeneratorUtils.createFieldNamesMethod());

        // 2. getPropertyByName(String)
        classBuilder.addMethod(CodeGeneratorUtils.createGetPropertyByNameMethod(fields, utils));

        // 3. setPropertyByName(String, Object)
        classBuilder.addMethod(CodeGeneratorUtils.createSetPropertyByNameMethod(fields, utils));

        // 4. getPropertyType(String)
        classBuilder.addMethod(CodeGeneratorUtils.createGetPropertyTypeMethod(fields));

        // 5. createNestedObject(String)
        classBuilder.addMethod(CodeGeneratorUtils.createNestedObjectMethod(fields));

        // 6. createListElement(String)
        classBuilder.addMethod(CodeGeneratorUtils.createListElementMethod(fields));

        // 7. isListField(String)
        classBuilder.addMethod(CodeGeneratorUtils.createIsListFieldMethod(fields));

        // 8. isNestedObjectField(String)
        classBuilder.addMethod(CodeGeneratorUtils.createIsNestedObjectFieldMethod(fields));

        // 9-14. Map support methods
        CodeGeneratorUtils.addMapMethods(classBuilder, fields);

        // 15. Static factory method: of(Document)
        MethodSpec ofMethod = MethodSpec.methodBuilder("of")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(ClassName.get("com.arcadedb.database", "Document"), "doc")
                .returns(className)
                .addStatement("var instance = new $T()", className)
                .addStatement("return instance.fromArcadeDocument(doc)")
                .build();
        classBuilder.addMethod(ofMethod);

        // Build and write the file
        TypeSpec classSpec = classBuilder.build();
        JavaFile javaFile = JavaFile.builder(packageName, classSpec)
                .indent("    ")
                .skipJavaLangImports(true)
                .addFileComment("Generated by ArcadeDataProcessor on " + LocalDateTime.now())
                .addStaticImport(ClassName.get("xyz.jphil.arcadedb.datahelper", "SchemaBuilder"), "defType")
                .build();

        try {
            javaFile.writeTo(processingEnv.getFiler());
            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                    "Generated sealed abstract class: " + abstractClassName + " for class: " + className);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Failed to generate sealed abstract class: " + e.getMessage());
        }
    }

    /**
     * Generate schemaBuilder() helper that pre-fills class, fields, and type.
     * User only needs to specify unique constraints, indexes, etc.
     *
     * <pre>
     * public static SchemaBuilder{@code <Person>} schemaBuilder() {
     *     return defType(Person.class, ArcadeType.VERTEX).fields(FIELDS);
     * }
     * </pre>
     *
     * @param arcadeType The type from @ArcadeData annotation ("DOCUMENT", "VERTEX", or "EDGE")
     */
    private void addTypeDefHelper(TypeSpec.Builder classBuilder, String packageName, String className, String arcadeType) {
        MethodSpec schemaBuilderHelper = MethodSpec.methodBuilder("schemaBuilder")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(ParameterizedTypeName.get(
                        ClassName.get("xyz.jphil.arcadedb.datahelper", "SchemaBuilder"),
                        ClassName.get(packageName, className)))
                .addStatement("return defType($T.class, $T.$L).fields(FIELDS)",
                        ClassName.get(packageName, className),
                        ClassName.get("xyz.jphil.arcadedb.datahelper", "ArcadeType"),
                        arcadeType)
                .build();
        classBuilder.addMethod(schemaBuilderHelper);
    }
}
