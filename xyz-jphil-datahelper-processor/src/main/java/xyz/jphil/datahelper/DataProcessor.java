package xyz.jphil.datahelper;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.*;
import xyz.jphil.datahelper.processor.util.CodeGeneratorUtils;
import xyz.jphil.datahelper.processor.util.FieldAnalyzer;
import xyz.jphil.datahelper.processor.util.FieldInfo;
import xyz.jphil.datahelper.processor.util.ProcessorUtils;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

/**
 * Annotation processor that generates {ClassName}_A sealed abstract parent class.
 *
 * <p>Generated code includes:
 * <ul>
 *   <li>Sealed abstract class that permits only the annotated class</li>
 *   <li>Field symbols ($fieldName constants)</li>
 *   <li>FIELDS list (immutable)</li>
 *   <li>Delegating getters/setters (access child's package-private fields)</li>
 *   <li>Fluent accessors</li>
 *   <li>DataHelper_I implementation (15 property accessor methods)</li>
 * </ul>
 *
 * <p>The child class extends the generated sealed abstract class and declares
 * package-private fields that the parent accesses via the {@code sub} reference.</p>
 *
 * <h3>Example Usage:</h3>
 * <pre>
 * {@code @Data}
 * public final class Person extends Person_A {
 *     String name;
 *     String email;
 *     Integer age;
 * }
 * </pre>
 *
 * <p>This eliminates Lombok dependency and reduces boilerplate compared to
 * the {@code @DataHelper} + {@code @Data} pattern. Design inspired by @ArcadeData
 * but at the base DataHelper level without ArcadeDB-specific dependencies.</p>
 *
 * @see Data
 * @see DataHelper_I
 */
@AutoService(Processor.class)
@SupportedAnnotationTypes("xyz.jphil.datahelper.Data")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class DataProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) {
                if (element.getKind() == ElementKind.CLASS) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                            "Processing @Data on " + element);
                    generateAbstractClass((TypeElement) element);
                }
            }
        }
        return true;
    }

    private void generateAbstractClass(TypeElement element) {
        String packageName = processingEnv.getElementUtils().getPackageOf(element).toString();
        String className = element.getSimpleName().toString();
        String abstractClassName = className + "_A";

        // Initialize utilities
        ProcessorUtils utils = new ProcessorUtils(processingEnv);
        FieldAnalyzer analyzer = new FieldAnalyzer(processingEnv, utils);

        // Analyze fields (includes validation)
        List<FieldInfo> fields = analyzer.analyzeFields(element);
        if (fields == null) {
            return; // Validation errors found
        }

        // Build sealed abstract class
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(abstractClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.SEALED)
                .addPermittedSubclass(ClassName.get(packageName, className))
                .addJavadoc("Sealed abstract base class for {@link $L}.\n", className)
                .addJavadoc("Generated by @Data annotation processor.\n")
                .addJavadoc("\n<p>This class implements DataHelper_I,\n")
                .addJavadoc("providing all accessor methods via delegation to the child class.</p>\n");

        // Implement DataHelper_I
        classBuilder.addSuperinterface(ParameterizedTypeName.get(
                ClassName.get("xyz.jphil.datahelper", "DataHelper_I"),
                ClassName.get(packageName, className)
        ));

        // Add 'sub' field for delegation (opposite of 'super')
        FieldSpec subField = FieldSpec.builder(
                        ClassName.get(packageName, className),
                        "sub",
                        Modifier.PRIVATE, Modifier.FINAL)
                .initializer("($T) this", ClassName.get(packageName, className))
                .build();
        classBuilder.addField(subField);

        // Add field symbols ($fieldName constants)
        CodeGeneratorUtils.addFieldSymbols(classBuilder, fields, packageName, className);

        // Add FIELDS list
        CodeGeneratorUtils.addFieldsList(classBuilder, fields, packageName, className);

        // Add delegating getters
        for (FieldInfo field : fields) {
            // For boolean types, generate BOTH "is" and "get" getters for maximum compatibility
            if (ProcessorUtils.isBooleanType(field.type)) {
                // Generate isXxx() method
                String isGetterName = "is" + ProcessorUtils.capitalize(field.name);
                MethodSpec isGetter = MethodSpec.methodBuilder(isGetterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return sub.$N", field.name)
                        .build();
                classBuilder.addMethod(isGetter);

                // Generate getXxx() method (delegates to isXxx for consistency)
                String getGetterName = "get" + ProcessorUtils.capitalize(field.name);
                MethodSpec getGetter = MethodSpec.methodBuilder(getGetterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return $N()", isGetterName)
                        .build();
                classBuilder.addMethod(getGetter);
            } else {
                // For non-boolean types, use standard "get" prefix
                String getterName = "get" + ProcessorUtils.capitalize(field.name);
                MethodSpec getter = MethodSpec.methodBuilder(getterName)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(field.type)
                        .addStatement("return sub.$N", field.name)
                        .build();
                classBuilder.addMethod(getter);
            }
        }

        // Add delegating setters
        for (FieldInfo field : fields) {
            String setterName = "set" + ProcessorUtils.capitalize(field.name);
            MethodSpec setter = MethodSpec.methodBuilder(setterName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(field.type, field.name)
                    .addStatement("sub.$N = $N", field.name, field.name)
                    .build();
            classBuilder.addMethod(setter);
        }

        // Add fluent getters
        for (FieldInfo field : fields) {
            // Use "is" prefix for boolean types (primitive boolean and Boolean wrapper)
            String prefix = ProcessorUtils.isBooleanType(field.type) ? "is" : "get";
            String getterName = prefix + ProcessorUtils.capitalize(field.name);
            MethodSpec fluentGetter = MethodSpec.methodBuilder(field.name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(field.type)
                    .addStatement("return $N()", getterName)
                    .build();
            classBuilder.addMethod(fluentGetter);
        }

        // Add fluent setters (return 'sub' for chaining)
        for (FieldInfo field : fields) {
            String setterName = "set" + ProcessorUtils.capitalize(field.name);
            MethodSpec fluentSetter = MethodSpec.methodBuilder(field.name)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(field.type, field.name)
                    .returns(ClassName.get(packageName, className))
                    .addStatement("$N($N)", setterName, field.name)
                    .addStatement("return sub")
                    .build();
            classBuilder.addMethod(fluentSetter);
        }

        // ========== DataHelper_I Methods (15 property accessor methods) ==========
        // 0. dataClass()
        classBuilder.addMethod(CodeGeneratorUtils.createDataClassMethod(packageName, className));

        // 1. fieldNames()
        classBuilder.addMethod(CodeGeneratorUtils.createFieldNamesMethod());

        // 2. getPropertyByName(String)
        classBuilder.addMethod(CodeGeneratorUtils.createGetPropertyByNameMethod(fields, utils));

        // 3. setPropertyByName(String, Object)
        classBuilder.addMethod(CodeGeneratorUtils.createSetPropertyByNameMethod(fields, utils));

        // 4. getPropertyType(String)
        classBuilder.addMethod(CodeGeneratorUtils.createGetPropertyTypeMethod(fields));

        // 5. createNestedObject(String)
        classBuilder.addMethod(CodeGeneratorUtils.createNestedObjectMethod(fields));

        // 6. createListElement(String)
        classBuilder.addMethod(CodeGeneratorUtils.createListElementMethod(fields));

        // 7. isListField(String)
        classBuilder.addMethod(CodeGeneratorUtils.createIsListFieldMethod(fields));

        // 8. isNestedObjectField(String)
        classBuilder.addMethod(CodeGeneratorUtils.createIsNestedObjectFieldMethod(fields));

        // 9-14. Map support methods
        CodeGeneratorUtils.addMapMethods(classBuilder, fields);

        // Build and write the file
        TypeSpec classSpec = classBuilder.build();
        JavaFile javaFile = JavaFile.builder(packageName, classSpec)
                .indent("    ")
                .skipJavaLangImports(true)
                .addFileComment("Generated by DataProcessor on " + LocalDateTime.now())
                .build();

        try {
            javaFile.writeTo(processingEnv.getFiler());
            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                    "Generated sealed abstract class: " + abstractClassName + " for class: " + className);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Failed to generate sealed abstract class: " + e.getMessage());
        }
    }
}
